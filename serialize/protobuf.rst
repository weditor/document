
Protobuf
=================================

.. image:: /_static/images/serialize/protobuf-example.svg


简介
------------------------

Protobuf 是 google 推出的一种序列化格式, 应用非常广泛，如 grpc、tfrecord。

* 内部编码: https://developers.google.com/protocol-buffers/docs/encoding
* 使用文档: https://developers.google.com/protocol-buffers/docs/proto3
* 支持的数据格式: https://developers.google.com/protocol-buffers/docs/reference/google.protobuf

+------+----------------------------+----------------------------------------------------------+
| 类型 |            含义            |                     适用类型(子类型)                     |
+======+============================+==========================================================+
| 0    | Varint(变长数值)           | int32, int64, uint32, uint64, sint32, sint64, bool, enum |
+------+----------------------------+----------------------------------------------------------+
| 1    | 64-bit(64位数值)           | fixed64, sfixed64, double                                |
+------+----------------------------+----------------------------------------------------------+
| 2    | Length-delimited(指定长度) | string, bytes, embedded messages, packed repeated fields |
+------+----------------------------+----------------------------------------------------------+
| 3    | Start group                | groups (deprecated)                                      |
+------+----------------------------+----------------------------------------------------------+
| 4    | End group                  | groups (deprecated)                                      |
+------+----------------------------+----------------------------------------------------------+
| 5    | 32-bit(32位数值)           | fixed32, sfixed32, float                                 |
+------+----------------------------+----------------------------------------------------------+

每一个字段首字节表示类型, byte 末3位是主类型, 前5位是子类型。

.. image:: /_static/images/serialize/type-spec.svg

上图表示主类型为0，子类型为 2 的类型（子类型最小值为1），即int64。

定长类型

    比较简单，当出现定常类型的typ, 后面只需要根据type取固定长度字节解释为对应类型，
    1、5 两种主类型都是定常类型。

变长类型

    这里的变长类型特指变长数值 - Varint 。 Varint 数值区域中每个 byte 首位标识后面还有没有内容。
    当首位为1，表示后面还有内容，为 0 表示当前已经是最后一字节。

    这种变长策略是 Protobuf 的亮点, 使整数类型的存储非常紧凑，小整数通常只会占 1 byte，越大的整数占据更多 byte 。

指定长度

    字符串、结构体等类型长度没有上限，都需要手动指定长度，所以除了首字节type，还有第二段内容说明数据长度，
    再后面才是真正的数据。

Protobuf 编码规则并不复杂, 由于有 type 的概念，某种程度上可以理解为 schemaless, 
但在实际使用过程中，protobuf是具有 schema 的, 其 schema 可以对数据做出不同解释。

比如 protobuf 支持的 option、默认值、数组、结构体等概念，
都是在 .proto 文件中描述的，还有涉及到向后兼容性等功能，proto 层实现了大量类似的逻辑。

另一种古老而广泛应用的序列化格式是 `ASN.1 <https://zh.wikipedia.org/wiki/ASN.1>`_ 。
protobuf 借鉴了它的协议描述层，并且定义了数据编码格式， 而 ASN.1 并没有限定数据编码格式，
底层实现可以选择 json、xml 等任意编码格式，甚至是私有编码格式，所以不做过多讨论。


总结
------------------------

从各方面讲 Protobuf 比 json 更像是一种合格的序列化格式。
从上面的描述可以看出，Protobuf 有一定的编解码的性能损耗，但是消耗不大。

同时 protobuf 对编程非常友好，强类型、跨平台跨语言、周边完善。
属于序列化方面的大一统框架，各方面比较平衡。
